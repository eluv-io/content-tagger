
from copy import deepcopy
from podman import PodmanClient
from loguru import logger
import json
import os
import psutil

from common_ml.utils.files import get_file_type
from common_ml.video_processing import get_fps

from src.common.schema import FrameTag
from src.common.errors import MissingResourceError, BadRequestError
from src.tags.tagstore.types import Tag
from src.tag_containers.types import ContainerSpec, RegistryConfig, ModelOutput, ModelConfig

class TagContainer:

    def __init__(
        self,
        pclient: PodmanClient,
        cfg: ContainerSpec
    ):
        self.cfg = cfg
        file_types = [get_file_type(f) for f in self.cfg.fileargs]
        if len(set(file_types)) > 1:
            raise BadRequestError("All files must be of the same type")
        self.file_type = file_types[0]
        if self.file_type not in ["video", "frame", "image"]:
            raise BadRequestError(f"Unsupported file type: {self.file_type}")
        # check that no file has the same basename
        self.basename_to_source = {os.path.splitext(os.path.basename(f))[0]: f for f in self.cfg.fileargs}
        if len(self.basename_to_source) != len(self.cfg.fileargs):
            raise BadRequestError("Files must have unique basenames")
        self.pclient = pclient
        self.container = None

    def start(
        self, 
        gpuidx: int | None,
    ) -> None:

        volumes = [
            {
                "source": self.cfg.tagspath,
                # convention for containers to store tags in /elv/tags
                "target": "/elv/tags",
                "type": "bind",
            },
            {
                "source": self.cfg.cachepath,
                # convention for python modules to store cache in /root/.cache
                "target": "/root/.cache",
                "type": "bind",
                "read_only": False
            }
        ]

        for f in self.cfg.fileargs:
            if not os.path.exists(f):
                raise FileNotFoundError(f"File {f} not found")
            elif not os.path.isfile(f):
                raise IsADirectoryError(f"{f} is a directory")
            elif not os.path.isabs(f):
                raise ValueError(f"{f} must be an absolute path")
            # mount the file
            volumes.append({
                "source": f,
                "target": f"/elv/{os.path.basename(f)}",
                "type": "bind",
                "read_only": True
            })

        kwargs = {
            "command": [f"{os.path.basename(f)}" for f in self.cfg.fileargs] + ["--config", f"{json.dumps(self.cfg.runconfig)}"],
            "mounts": volumes,
            "remove": True,
            "network_mode": "host",
            "log_config": {
                "type": "file",
                "path": self.cfg.logspath,
            }
        }

        if gpuidx is not None:
            kwargs["devices"] = [f"nvidia.com/gpu={gpuidx}"]

        container = self.pclient.containers.create(**kwargs)
        container.start()
        self.container = container

    def stop(self) -> None:
        if not self.container:
            return
        if self.container.status == "running":
            # podman client will kill if it doesn't stop within the timeout limit
            self.container.stop(timeout=5)
        if self.is_running():
            logger.warning(f"Container {self.container.id} did not stop in time, killing it")
            self.container.kill()

    def is_running(self) -> bool:
        if self.container is None:
            return False
        self.container.reload()
        return self.container.status == "running" or self.container.status == "created"

    def tags(self) -> list[ModelOutput]:
        """
        Get output tags generated by the running container so far.
        """

        tag_files = []
        for fpath in os.listdir(self.cfg.tagspath):
            tag_files.append(os.path.join(self.cfg.tagspath, fpath))

        tag_files = self._filter_open_fd(tag_files)
        return self._files_to_tags(tag_files)
    
    def _filter_open_fd(self, tag_files: list[str]) -> list[str]:
        pid = None
        if self.is_running():
            try:
                container_info = self.container.inspect()
                pid = container_info.get("State", {}).get("Pid")
            except Exception as e:
                logger.error(f"Error getting container PID: {e}")

        if pid:
            # Get the process and its open files
            process = psutil.Process(pid)
            for open_file in process.open_files():
                if open_file.path in tag_files:
                    # TODO: check that it's full path.
                    tag_files.remove(open_file.path)

        return tag_files

    def _files_to_tags(self, tagged_files: list[str]) -> list[ModelOutput]:

        if self.file_type == "image":
            return self._load_image_tags(tagged_files)
        else:
            return self._load_video_tags(tagged_files)
        
    def _load_image_tags(self, tagged_files: list[str]) -> list[ModelOutput]:
        outputs = []
        for tagged_file in tagged_files:
            source = self._source_from_tag_file(tagged_file)
            image_tags = []
            with open(tagged_file, 'r') as f:
                image_tags = json.load(f)
            outputs.append(self._output_from_image_tags(source, image_tags))
        return outputs

    def _output_from_image_tags(self, source_image: str, image_tags: list[dict]) -> ModelOutput:
        tags = []
        for image_tag_data in image_tags:
            tags.append(Tag(
                start_time=0,
                end_time=0,
                text=image_tag_data.get("text", ""),
                additional_info={
                    "confidence": image_tag_data.get("confidence", 0.0),
                    "box": image_tag_data.get("box", [])
                },
                source="",
                jobid=""
            ))

        return ModelOutput(
            source_media=source_image,
            tags=tags
        )
        
    def _load_video_tags(self, tagged_files: list[str]) -> list[ModelOutput]:
        
        source_to_tagfiles = {}

        for tagged_file in tagged_files:
            source_media = self._source_from_tag_file(tagged_file)
            if source_media not in source_to_tagfiles:
                source_to_tagfiles[source_media] = []
            source_to_tagfiles[source_media].append(tagged_file)

        outputs = []
        for source_media, tag_files in source_to_tagfiles.items():
            model_out = self._output_from_tags(source_media, tag_files)
            if model_out:
                outputs.append(self._output_from_tags(source_media, tag_files))

        return outputs
    
    def _output_from_tags(self, source_video: str, tag_files: list[str]) -> ModelOutput | None:
        fps = get_fps(source_video)

        vid_tags = None
        frame_tags = None

        for tag_file in tag_files:
            if tag_file.endswith("_tags.json"):
                with open(tag_file, 'r') as f:
                    vid_tags = json.load(f)
            elif tag_file.endswith("_frametags.json"):
                with open(tag_file, 'r') as f:
                    frame_tags = json.load(f)
        
        if vid_tags is None:
            return None

        # Convert video tags to Tag objects with enhanced additional_info
        tags = []

        for video_tag_data in vid_tags:
            # Create base Tag object from video tag
            tag = Tag(
                start_time=video_tag_data.get("start_time", 0),
                end_time=video_tag_data.get("end_time", 0),
                text=video_tag_data.get("text", ""),
                additional_info={},
                source="",
                jobid=""
            )

            if frame_tags:
                
                # Find overlapping frame tags with matching text
                overlapping_frame_tags = self._find_overlapping_frame_tags(
                    tag, frame_tags, fps
                )
                
                # Enhance additional_info with frame tag data
                if overlapping_frame_tags:
                    frame_info = {}
                    for ftag in overlapping_frame_tags:
                        frame_info[ftag.frame_idx] = {
                            "confidence": ftag.confidence,
                            "box": ftag.box
                        }
                    tag.additional_info["frame_tags"] = frame_info

            tags.append(tag)

        return ModelOutput(
            source_media=source_video,
            tags=tags
        )

    def _source_from_tag_file(self, tagfile: str) -> str:
        """
        Extract the source from the tag file name.
        """
        basename = os.path.splitext(os.path.basename(tagfile))[0]
        # remove _tags, _frametags, or _imagetags suffix
        if basename.endswith("_tags"):
            basename = basename[:-5]
        elif basename.endswith("_frametags"):
            basename = basename[:-10]
        elif basename.endswith("_imagetags"):
            basename = basename[:-10]
        else:
            raise ValueError(f"Invalid tag file name: {tagfile}")
        
        return self.basename_to_source[basename]
    
    def _find_overlapping_frame_tags(
        self, 
        video_tag: Tag, 
        frame_tags_data: dict, 
        fps: float
    ) -> list[FrameTag]:
        overlapping_tags = []
        for fidx, ftag_data in frame_tags_data.items():
            frame_time = int(fidx) / fps
            if video_tag.start_time <= frame_time <= video_tag.end_time \
                and ftag_data.get("text", "") == video_tag.text:
                overlapping_tags.append(FrameTag(
                    frame_idx=fidx,
                    confidence=ftag_data.get("confidence", 0.0),
                    box=ftag_data.get("box", []),
                    text=ftag_data.get("text", "")
                ))
        return overlapping_tags


class ContainerRegistry:
    """
    Get runnable containers through identifier
    """

    def __init__(self, cfg: RegistryConfig):
        self.pclient = PodmanClient()
        self.cfg = cfg
        os.makedirs(self.cfg.logspath, exist_ok=True)
        os.makedirs(self.cfg.tagspath, exist_ok=True)
        os.makedirs(self.cfg.cachepath, exist_ok=True)

    def get(self, model: str, fileargs: list[str], runconfig: dict) -> TagContainer:
        tagspath = os.path.join(self.cfg.tagspath, model)
        logspath = os.path.join(self.cfg.logspath, model)
        cachepath = os.path.join(self.cfg.cachepath, model)

        modelcfg = self.cfg.modconfigs.get(model)
        if not modelcfg:
            raise MissingResourceError(f"Model {model} not found")

        ccfg = ContainerSpec(
            fileargs=fileargs,
            runconfig=runconfig,
            logspath=logspath,
            cachepath=cachepath,
            tagspath=tagspath,
            model_config=modelcfg
        )

        return TagContainer(self.pclient, ccfg)

    def get_model_config(self, model: str) -> ModelConfig:
        return deepcopy(self.cfg.modconfigs[model])

    def services(self) -> list[str]:
        """
        Returns a list of available services
        """
        # TODO: check if the image exists
        return list(self.cfg.modconfigs.keys())